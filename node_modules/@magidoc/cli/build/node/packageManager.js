import { exec, spawn } from 'child_process';
import { promisify } from 'util';

const execPromise = promisify(exec);
const PACKAGE_MANAGER_TYPES = ['pnpm', 'yarn', 'npm'];
async function selectPackageManager() {
    if (await isPackageManagerAvailable('pnpm')) {
        return createPnpm();
    }
    if (await isPackageManagerAvailable('npm')) {
        return createNpm();
    }
    if (await isPackageManagerAvailable('yarn')) {
        return createYarn();
    }
    throw new Error(`No Package Manager runner was found among on of the following: ${PACKAGE_MANAGER_TYPES.toString()}. Make sure that one of these is installed.`);
}
function getPackageManager(type) {
    if (type === 'pnpm')
        return createPnpm();
    if (type === 'yarn')
        return createYarn();
    if (type === 'npm')
        return createNpm();
    throw new Error(`Unknown package manager ${type}.`);
}
function createPnpm() {
    return createRunner({ type: 'pnpm' });
}
function createYarn() {
    return createRunner({ type: 'yarn', installArgs: ['--non-interactive'] });
}
function createNpm() {
    return createRunner({ type: 'npm', installArgs: ['--legacy-peer-deps'] });
}
function createRunner({ type, installArgs, }) {
    return {
        type,
        runInstall: (config) => runNodeCommand(type, ['install', ...(installArgs || [])], config),
        buildProject: (config) => runNodeCommand(type, ['run', 'build'], config),
        startDevServer: (config) => runNodeCommand(type, ['run', 'dev', '--host', config.host, '--port', config.port.toString()], config),
    };
}
async function runNodeCommand(command, args, config) {
    return new Promise((resolve, reject) => {
        const child = spawn(command, args, {
            cwd: config.cwd,
            shell: true,
            env: {
                ...getCurrentEnvironment(),
                ...config.env,
            },
        });
        let output = '';
        const stdHandler = (chunk) => {
            output += String(chunk);
        };
        child.stdout.on('data', stdHandler);
        child.stderr.on('data', stdHandler);
        child.on('error', (error) => {
            reject(new Error(`Failed to launch command '${command}' with args '${args.toString()}' and config '${JSON.stringify(config)}': ${error.message}`, {
                cause: error,
            }));
        });
        child.on('exit', (code) => {
            if (code === 0) {
                resolve();
            }
            else {
                reject(new Error(`Command '${command}' failed with status ${code?.toString() || 'unknown'} when executed in directory ${config.cwd}\n\n---- Program Output----\n${output}`));
            }
        });
    });
}
async function isPackageManagerAvailable(type) {
    try {
        await execPromise(`${type} --version`);
        return true;
    }
    catch (error) {
        return false;
    }
}
function getCurrentEnvironment() {
    return Object.keys(process.env).reduce((previous, key) => {
        const lowerKey = key.toLowerCase();
        if (lowerKey.startsWith('vercel') ||
            lowerKey.startsWith('netlify') ||
            lowerKey.startsWith('cf_pages')) {
            return previous;
        }
        return {
            ...previous,
            [key]: process.env[key],
        };
    }, {});
}

export { PACKAGE_MANAGER_TYPES, getPackageManager, isPackageManagerAvailable, selectPackageManager };
//# sourceMappingURL=packageManager.js.map
