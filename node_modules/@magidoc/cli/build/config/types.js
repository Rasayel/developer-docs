import z from 'zod';
import { AVAILABLE_TEMPLATES } from '../template/index.js';
import { getVersion } from '../version.js';
import path from 'path';
import { isDirectory } from '../commands/utils/fileUtils.js';

const ZPath = z
    .string()
    .min(1)
    .transform((arg) => path.resolve(arg));
const ZTemplate = z
    .string()
    .min(1)
    .refine((arg) => {
    if (AVAILABLE_TEMPLATES.some((template) => template === arg)) {
        return true;
    }
    return isDirectory(arg);
}, {
    message: `Template should be either a valid template name among [${AVAILABLE_TEMPLATES.join(', ')}] or a path to a Magidoc template directory`,
});
const ZIntrospectionConfiguration = z.discriminatedUnion('type', [
    z.object({
        type: z.literal('url'),
        url: z.string().url(),
        query: z.string().min(1).optional(),
        method: z.enum(['GET', 'POST', 'PUT', 'DELETE']).default('POST'),
        headers: z.record(z.string().min(1), z.string()).optional(),
    }),
    z.object({
        type: z.literal('sdl'),
        paths: z.array(ZPath).nonempty(),
    }),
    z.object({
        type: z.literal('raw'),
        content: z.string().min(1),
    }),
    z.object({
        type: z.literal('none'),
    }),
]);
const ZWebsiteConfiguration = z.object({
    template: ZTemplate,
    templateVersion: z.string().min(1).default(getVersion()),
    output: ZPath.default(path.resolve('./docs')),
    staticAssets: ZPath.optional(),
    options: z.record(z.string().min(1), z.unknown()).default({}),
});
const ZDevConfiguration = z
    .object({
    watch: z.array(ZPath).default([]),
})
    .default({});
const ZMagidocConfiguration = z.object({
    introspection: ZIntrospectionConfiguration,
    website: ZWebsiteConfiguration,
    dev: ZDevConfiguration,
});

export { ZDevConfiguration, ZIntrospectionConfiguration, ZMagidocConfiguration, ZWebsiteConfiguration };
//# sourceMappingURL=types.js.map
